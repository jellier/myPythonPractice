# 正则表达式库re的用法
# https://www.cnblogs.com/zjltt/p/6955965.html
# 第一步：导入re
import re

# 第二步，调用模块函数
a = re.findall("匹配规则", "匹配规则测试，查找这个字符串是否有匹配规则的字符")

# 第三步：以列表形式返回匹配到的字符串
# 返回 ['匹配规则', '匹配规则']
print('a的值是：%s' % a)

# ^元字符，匹配字符串开头。在多行模式中匹配每一行的开头
# ^元字符如果写到[]字符集里就是反取
b = re.findall("^匹配规则", "匹配规则测试，查找这个字符串是否有匹配规则的字符")
# 返回 ['匹配规则']，如果上面字符串前几个字不是"匹配规则"则返回【】
print('b的值是：%s' % b)

# 反取，匹配出除字母外的字符
c = re.findall("[^a-z]", "匹配s规则这s个字符串是否s匹配f规则则re则则则")
print('c的值是：%s' % c)

# $元字符，与^相反，匹配的是字符串结尾
d = re.findall("匹配规则$", "匹配规则测试，查找这个字符串是否有匹配规则")
print('d的值是：%s' % d)

# *元字符，+元字符
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的*、+元字符）前面的一个字符可以是0(*)/1(+)个或多个原本字符
# 匹配前一个字符0(*)/1(+)或多次，贪婪匹配前导字符有多少个就匹配多少个很贪婪
# 如果规则里只有一个分组，尽量避免用*否则会有可能匹配出空字符串
e = re.findall("匹配规则*", "这个字符串是否匹配规则则则则则匹配规则则")
e2 = re.findall("匹配规则*", "这个字符串是否匹配规")
f = re.findall("匹配规则+", "这个字符串是否匹配规则则则则则匹配规则则")
f2 = re.findall("匹配规则+", "这个字符串是否匹配规")
print('e的值是：%s' % e)
print('e2的值是：%s' % e2)
print('f的值是：%s' % f)
print('f2的值是：%s' % f2)

# ?元字符，和防止贪婪匹配
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是0个或1个原本字符
# 匹配一个字符0次或1次，还有一个功能是可以防止贪婪匹配

g = re.findall("匹配规则?", "匹配规这个字符串是否匹配规则则则则则")
print('g的值是：%s' % g)  # 返回['匹配规', '匹配规则']

# {}范围
# {0,}匹配前一个字符0或多次,等同于*元字符
# {+,}匹配前一个字符1次或无限次,等同于+元字符
# {0,1}匹配前一个字符0次或1次,等同于?元字符
# {m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次
h = re.findall("匹配规则{3}", "匹配规这个字符串是否匹配规则则则则则")
print('h的值是：%s' % h)

# []元字符,字符集
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配
# 字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。
# 所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。
i = re.findall("匹配[a,b,c]规则", "匹配a规则这个字符串是否匹配b规则则则则则")
print('i的值是：%s' % i)


# 反斜杠后边跟普通字符实现特殊功能；（即预定义字符）
# 预定义字符是在字符集和组里都是有用的


# \d匹配任何十进制数，它相当于类[0-9]
# \d+匹配一位或者多位数字时使用
# \D匹配任何非数字字符，它相当于类[^0-9]
j1 = re.findall(r"\d", "匹配规则这2个字符串3是否匹配规则5则则则7则")   # 返回['2', '3', '5', '7']
# 返回['2', '134444', '5', '7']
j2 = re.findall(r"\d+", "匹配规则这2个字符串134444是否匹配规则5则则则7则")
# 返回['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']
j3 = re.findall(r"\D", "匹配规则这2个字符串3是否匹配规则5则则则7则")
print('j1的值是：%s' % j1)
print('j2的值是：%s' % j2)
print('j3的值是：%s' % j3)

# \s匹配任何空白字符，它相当于类[\t\n\r\f\v]
k1 = re.findall(r"\s", "匹配规则   这2个字符串3是否匹\n配规则5则则则7则")
# \S匹配任何非空白字符，它相当于类[^\t\n\r\f\v]
k2 = re.findall(r"\S", "匹配规则   这2个字符串3是否匹\n配规则5则则则7则")
print('k1的值是：%s' % k1)
print('k2的值是：%s' % k2)

# \w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]
# \W匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]
l1 = re.findall(r'\w', "https://www.cnblogs.com/")
l2 = re.findall(r'\W', "https://www.cnblogs.com/")
print('l1的值是：%s' % l1)
print('l2的值是：%s' % l2)

# ()元字符，分组
# 也就是分组匹配，()里面的为一个组也可以理解成一个整体
# 如果()后面跟的是特殊元字符如   (adc)*   那么*控制的前导字符就是()里的整体内容，不再是前导一个字符
m = re.search("(a4)+", "a4a4a4a4a4dg4g654gb")  # 匹配一个或多个a4
m2 = m.group()
print('m2的值是：%s' % m2)

# 匹配 (a) (\d0-9的数字) (+可以是1个到多个0-9的数字)
m3 = re.search(r"a(\d+)", "a466666664a4a4a4dg4g654gb")
m3 = m3.group()
print('m3的值是：%s' % m3)

# |元字符，或
# |或，或就是前后其中一个符合就匹配

n = re.findall(r"你|好", "a4a4a你4aabc4a4dgg好dg4g654g")  # |或，或就是前后其中一个符合就匹配
print('n的值是：%s' % n)

# ==========================================================================================================================
# RE模块常用功能函数


# match()函数（以后常用）
# match，从头匹配一个符合规则的字符串，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
# match(pattern, string, flags=0)
# # pattern： 正则模型
# # string ： 要匹配的字符串
# # falgs ： 匹配模式
#
# 注意：match()函数 与
# search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串


# 无分组
origin = "hello egon bcd egon lge egon acd 19"
r = re.match(r"h\w+", origin)  # match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
print('r的group值是：%s' % r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
# 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
print('r的groupdict值是：%s' % r.groupdict())
# 输出结果
# hello     匹配到的全部拿出来
# ()        没有分组所以为空
# {}        没分组部分定义了key的组所以为空


# 有分组
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
r1 = re.match(r"h(\w+)", origin)  # match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
print('r1的group值是：%s' % r1.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print('r1的groups值是：%s' % r1.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
# 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
print('r1的groupdict值是：%s' % r1.groupdict())
# 输出结果
# hello         匹配到的全部拿出来
# ('ello',)     有分组，在匹配到的字符串中拿出分组的部分
# {}            没分组部分定义了key的组所以为空


# 有两个分组定义了key
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
# ?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容
r2 = re.match(r"(?P<n1>h)(?P<n2>\w+)", origin)
print('r2的group值是：%s' % r2.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r2.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
# 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
print('r2的groupdict值是：%s' % r2.groupdict())
# 输出结果
# hello                         匹配到的全部拿出来
# ('h', 'ello')                 有分组，在匹配到的字符串中拿出分组的部分
# {'n1': 'h', 'n2': 'ello'}     有定义了key的组所以，将定义了key的组里的内容以字典形式拿出来


# search()函数
# search,浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None
# search(pattern, string, flags=0)
# # pattern： 正则模型
# # string ： 要匹配的字符串
# # falgs ： 匹配模式
#
# 注意：match()函数 与
# search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串

# 无分组
origin = "hello alex bcd alex lge alex acd 19"
# search浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None
s = re.search(r"a\w+", origin)
print(s.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(s.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(s.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
# 输出结果
# alex     匹配到的全部拿出来
# ()        没有分组所以为空
# {}        没分组部分定义了key的组所以为空

# .元字符，需要字符串里完全符合，匹配规则，就匹配，（规则里的.元字符）可以是任何一个字符，匹配任意除换行符"\n"外的字符(在DOTALL模式中也能匹配换行符)
# 有分组
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
s1 = re.search(r"a(\w+).*(\d)", origin)
print(s1.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(s1.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(s1.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
# 输出结果
# alex bcd alex lge alex acd 19       匹配到的全部拿出来
# ('lex', '9')     有分组，在匹配到的字符串中拿出分组的部分
# {}            没分组部分定义了key的组所以为空


# 有两个分组定义了key
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
# ?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容
s2 = re.search(r"a(?P<n1>\w+).*(?P<n2>\d)", origin)
print(s2.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(s2.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(s2.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
# 输出结果
# alex bcd alex lge alex acd 19                         匹配到的全部拿出来
# ('lex', '9')                 有分组，在匹配到的字符串中拿出分组的部分
# {'n1': 'lex', 'n2': '9'}     有定义了key的组所以，将定义了key的组里的内容以字典形式拿出来

# ==============
# findall()函数
# 无分组
t = re.findall(r"\d+\w\d+", "a2b3c4d5")  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
print('findall 无分组:', t)
# 输出结果: ['2b3', '4d5'] ,
# 注意：匹配成功的字符串，不在参与下次匹配,所以3c4也符合规则但是没匹配到

t2 = re.findall("", "a2b3c4d5")  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
print('findall 没有匹配成功:', t2)
# 输出结果 ，['', '', '', '', '', '', '', '', '']
# 注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表

# 注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是*就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用*否则会有可能匹配出空字符串

# 注意：正则只拿组里最后一位，如果规则里只有一个组，匹配到的字符串里在拿组内容是，拿的是匹配到的内容最后一位
origin = "hello alex bcd alex lge alex acd 19"
t3 = re.findall("(a)*", origin)
print('findall 尽量避免使用*:', t3)
#输出结果 ['', '', '', '', '', '', 'a', '', '', '', '', '', '', '', '', 'a', '', '', '', '', '', '', '', '', 'a', '', '', '', '', 'a', '', '', '', '', '', '']

# 无分组: 匹配所有合规则的字符串，匹配到的字符串放到一个列表中
origin = "hello alex bcd alex lge alex acd 19"
t4 = re.findall(r"a\w+", origin)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
print('findall 无分组:', t4)
#输出结果: ['alex', 'alex', 'alex', 'acd']

# 有分组：只将匹配到的字符串里，组的部分放到列表里返回
t5 = re.findall(r"a(\w+)", origin)
print('findall 有分组:', t5)
#输出结果:['lex', 'lex', 'lex', 'cd']

# 多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返回
t6 = re.findall(r"(a)(\w+)", origin)
print('findall 多个分组:', t6)
#输出结果: [('a', 'lex'), ('a', 'lex'), ('a', 'lex'), ('a', 'cd')]

# 分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，
# 把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回
t7 = re.findall(r"(a)(\w+(e))", origin)
print('findall 分组中有分组:', t7)
#输出结果: [('a', 'le', 'e'), ('a', 'le', 'e'), ('a', 'le', 'e')]

# ?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()
t8 = re.findall(r"a(?:\w+)", origin)
print('findall ?:', t8)
#输出: ['alex', 'alex', 'alex', 'acd']

# ==============
# split()函数
# 根据正则匹配分割字符串，返回分割后的一个列表
#
# split(pattern, string, maxsplit=0, flags=0)
# # pattern： 正则模型
# # string ： 要匹配的字符串
# # maxsplit：指定分割个数
# # flags  ： 匹配模式
# 按照一个字符将全部字符串进行分割

origin = "hello alex bcd alex lge alex acd 19"
u = re.split("a", origin)  # 根据正则匹配分割字符串
print('split: ', u)
#输出结果 ['hello ', 'lex bcd ', 'lex lge ', 'lex ', 'cd 19'],  根据a进行分组

origin = "hello alex bcd alex lge alex 2acd 19"
u2 = re.split(r"a\w+", origin)  # 根据正则匹配分割字符串
print('split 2: ', u2)
#输出结果 ['hello ', ' bcd ', ' lge ', ' 2', ' 19']
# 将匹配到的字符串作为分割标准进行分割
# ==============
# sub()函数
# 替换匹配成功的指定位置字符串
# sub(pattern, repl, string, count=0, flags=0)

# pattern： 正则模型
# repl   ： 要替换的字符串
# string ： 要匹配的字符串
# count  ： 指定匹配个数
# flags  ： 匹配模式

origin = "hello alex bcd alex lge alex acd 19"
v = re.sub("a", "b", origin)  # 替换匹配成功的指定位置字符串
print('sub：', v)
# 输出 : hello blex bcd blex lge blex bcd 19

# ==============
# subn()函数
# 替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受
# subn(pattern, repl, string, count=0, flags=0)
# pattern： 正则模型
# repl   ： 要替换的字符串
# string ： 要匹配的字符串
# count  ： 指定匹配个数
# flags  ： 匹配模式

origin = "hello alex bcd alex lge alex acd 19"
w, x = re.subn("a", "A", origin)  # 替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受
print('subn 返回的字符串：', w)
print('subn 返回的匹配次数：', x)
# 输出
# hello Alex bcd Alex lge Alex Acd 19
# 4


# ==========================================================================================================================
# 正则表达式重点
#
# 一、r原生字符
# 将在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r

# 二、正则表达式，返回类型为表达式对象的
#
# 如： < _sre.SRE_Match object; span = (6, 7), match = 'a' > 返回对象的，需要用正则方法取字符串，
# 方法有：
# group()  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如2
# groups()  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
# groupdict()  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果

# 三、匹配到的字符串里出现空字符
#
# 注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是 * 就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用 * 否则会有可能匹配出空字符串
#
# 四、()分组
# 注意：分组的意义，就是在匹配成功的字符串中，在提取()里，组里面的字符串
#
# 五、?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()
