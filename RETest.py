# 正则表达式库re的用法
# https://www.cnblogs.com/zjltt/p/6955965.html
# 第一步：导入re
import re

# 第二步，调用模块函数
a = re.findall("匹配规则", "匹配规则测试，查找这个字符串是否有匹配规则的字符")

# 第三步：以列表形式返回匹配到的字符串
# 返回 ['匹配规则', '匹配规则']
print('a的值是：%s' % a)

# ^元字符，匹配字符串开头。在多行模式中匹配每一行的开头
# ^元字符如果写到[]字符集里就是反取
b = re.findall("^匹配规则", "匹配规则测试，查找这个字符串是否有匹配规则的字符")
# 返回 ['匹配规则']，如果上面字符串前几个字不是"匹配规则"则返回【】
print('b的值是：%s' % b)

#反取，匹配出除字母外的字符
c = re.findall("[^a-z]", "匹配s规则这s个字符串是否s匹配f规则则re则则则")
print('c的值是：%s' % c)

# $元字符，与^相反，匹配的是字符串结尾
d = re.findall("匹配规则$", "匹配规则测试，查找这个字符串是否有匹配规则")
print('d的值是：%s' % d)

# *元字符，+元字符
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的*、+元字符）前面的一个字符可以是0(*)/1(+)个或多个原本字符
# 匹配前一个字符0(*)/1(+)或多次，贪婪匹配前导字符有多少个就匹配多少个很贪婪
# 如果规则里只有一个分组，尽量避免用*否则会有可能匹配出空字符串
e = re.findall("匹配规则*", "这个字符串是否匹配规则则则则则匹配规则则")
e2 = re.findall("匹配规则*", "这个字符串是否匹配规")
f = re.findall("匹配规则+", "这个字符串是否匹配规则则则则则匹配规则则")
f2 = re.findall("匹配规则+", "这个字符串是否匹配规")
print('e的值是：%s' % e)
print('e2的值是：%s' % e2)
print('f的值是：%s' % f)
print('f2的值是：%s' % f2)

# ?元字符，和防止贪婪匹配
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是0个或1个原本字符
# 匹配一个字符0次或1次，还有一个功能是可以防止贪婪匹配

g = re.findall("匹配规则?", "匹配规这个字符串是否匹配规则则则则则")
print('g的值是：%s' % g) # 返回['匹配规', '匹配规则']

# {}范围
# {0,}匹配前一个字符0或多次,等同于*元字符
# {+,}匹配前一个字符1次或无限次,等同于+元字符
# {0,1}匹配前一个字符0次或1次,等同于?元字符
# {m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次
h = re.findall("匹配规则{3}", "匹配规这个字符串是否匹配规则则则则则")
print('h的值是：%s' % h)

# []元字符,字符集
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配
# 字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。
# 所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。
i = re.findall("匹配[a,b,c]规则", "匹配a规则这个字符串是否匹配b规则则则则则")
print('i的值是：%s' % i)



# 反斜杠后边跟普通字符实现特殊功能；（即预定义字符）
# 预定义字符是在字符集和组里都是有用的


# \d匹配任何十进制数，它相当于类[0-9]
# \d+匹配一位或者多位数字时使用
# \D匹配任何非数字字符，它相当于类[^0-9]
j1 = re.findall("\d", "匹配规则这2个字符串3是否匹配规则5则则则7则")   # 返回['2', '3', '5', '7']
j2 = re.findall("\d+", "匹配规则这2个字符串134444是否匹配规则5则则则7则")   # 返回['2', '134444', '5', '7']
j3 = re.findall("\D", "匹配规则这2个字符串3是否匹配规则5则则则7则")   # 返回['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']
print('j1的值是：%s' % j1)
print('j2的值是：%s' % j2)
print('j3的值是：%s' % j3)

# \s匹配任何空白字符，它相当于类[\t\n\r\f\v]
k1 = re.findall("\s", "匹配规则   这2个字符串3是否匹\n配规则5则则则7则")
# \S匹配任何非空白字符，它相当于类[^\t\n\r\f\v]
k2 = re.findall("\S", "匹配规则   这2个字符串3是否匹\n配规则5则则则7则")
print('k1的值是：%s' % k1)
print('k2的值是：%s' % k2)

# \w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]
# \W匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]
l1 = re.findall('\w',"https://www.cnblogs.com/")
l2 = re.findall('\W',"https://www.cnblogs.com/")
print('l1的值是：%s' % l1)
print('l2的值是：%s' % l2)

# ()元字符，分组
# 也就是分组匹配，()里面的为一个组也可以理解成一个整体
# 如果()后面跟的是特殊元字符如   (adc)*   那么*控制的前导字符就是()里的整体内容，不再是前导一个字符
m = re.search("(a4)+", "a4a4a4a4a4dg4g654gb")   #匹配一个或多个a4
m2 = m.group()
print('m2的值是：%s' % m2)

m3 = re.search("a(\d+)", "a466666664a4a4a4dg4g654gb")    #匹配 (a) (\d0-9的数字) (+可以是1个到多个0-9的数字)
m3 = m3.group()
print('m3的值是：%s' % m3)

# |元字符，或
# |或，或就是前后其中一个符合就匹配

n = re.findall(r"你|好", "a4a4a你4aabc4a4dgg好dg4g654g")   #|或，或就是前后其中一个符合就匹配
print('n的值是：%s' % n)

# ==========================================================================================================================
# RE模块常用功能函数


# match()函数（以后常用）
# match，从头匹配一个符合规则的字符串，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
# match(pattern, string, flags=0)
# # pattern： 正则模型
# # string ： 要匹配的字符串
# # falgs ： 匹配模式
#
# 注意：match()函数 与 search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串


#无分组
origin = "hello egon bcd egon lge egon acd 19"
r = re.match("h\w+", origin)    #match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
print('r的group值是：%s' % r.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print('r的groupdict值是：%s' % r.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
#输出结果
# hello     匹配到的全部拿出来
# ()        没有分组所以为空
# {}        没分组部分定义了key的组所以为空


# 有分组
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
r1 = re.match("h(\w+)", origin)   #match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
print('r1的group值是：%s' % r1.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print('r1的groups值是：%s' % r1.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print('r1的groupdict值是：%s' % r1.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
#输出结果
# hello         匹配到的全部拿出来
# ('ello',)     有分组，在匹配到的字符串中拿出分组的部分
# {}            没分组部分定义了key的组所以为空


# 有两个分组定义了key
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
r2 = re.match("(?P<n1>h)(?P<n2>\w+)", origin)   #?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容
print('r2的group值是：%s' % r2.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r2.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print('r2的groupdict值是：%s' % r2.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
#输出结果
# hello                         匹配到的全部拿出来
# ('h', 'ello')                 有分组，在匹配到的字符串中拿出分组的部分
# {'n1': 'h', 'n2': 'ello'}     有定义了key的组所以，将定义了key的组里的内容以字典形式拿出来


# search()函数
# search,浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None
# search(pattern, string, flags=0)
# # pattern： 正则模型
# # string ： 要匹配的字符串
# # falgs ： 匹配模式
#
# 注意：match()函数 与 search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串

#无分组
origin = "hello alex bcd alex lge alex acd 19"
s = re.search("a\w+", origin)    #search浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None
print(s.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(s.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(s.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
#输出结果
# alex     匹配到的全部拿出来
# ()        没有分组所以为空
# {}        没分组部分定义了key的组所以为空

# .元字符，需要字符串里完全符合，匹配规则，就匹配，（规则里的.元字符）可以是任何一个字符，匹配任意除换行符"\n"外的字符(在DOTALL模式中也能匹配换行符)
# 有分组
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
s1 = re.search("a(\w+).*(\d)", origin)
print(s1.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(s1.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(s1.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
#输出结果
# alex bcd alex lge alex acd 19       匹配到的全部拿出来
# ('lex', '9')     有分组，在匹配到的字符串中拿出分组的部分
# {}            没分组部分定义了key的组所以为空


# 有两个分组定义了key
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
s2 = re.search("a(?P<n1>\w+).*(?P<n2>\d)", origin)   #?P<>定义组里匹配内容的key(键)，<>里面写key名称，值就是匹配到的内容
print(s2.group())     # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(s2.groups())    # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(s2.groupdict()) # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果
#输出结果
# alex bcd alex lge alex acd 19                         匹配到的全部拿出来
# ('lex', '9')                 有分组，在匹配到的字符串中拿出分组的部分
# {'n1': 'lex', 'n2': '9'}     有定义了key的组所以，将定义了key的组里的内容以字典形式拿出来

# ==============
# findall()函数


# ==============
# split()函数

# ==============
# sub()函数

# ==============
# subn()函数





# ==========================================================================================================================
# 正则表达式重点
#
# 一、r原生字符
# 将在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r

# 二、正则表达式，返回类型为表达式对象的
#
# 如： < _sre.SRE_Match object; span = (6, 7), match = 'a' > 返回对象的，需要用正则方法取字符串，
# 方法有：
# group()  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如2
# groups()  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
# groupdict()  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果

# 三、匹配到的字符串里出现空字符
#
# 注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是 * 就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用 * 否则会有可能匹配出空字符串
#
# 四、()分组
# 注意：分组的意义，就是在匹配成功的字符串中，在提取()里，组里面的字符串
#
# 五、?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()